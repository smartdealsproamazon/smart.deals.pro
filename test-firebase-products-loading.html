<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebase Products Loading Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f7fa;
        }
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .status.success { background: #d1fae5; color: #065f46; }
        .status.error { background: #fee2e2; color: #991b1b; }
        .status.warning { background: #fef3c7; color: #92400e; }
        .status.info { background: #dbeafe; color: #1e40af; }
        .product-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .product-card {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }
        .product-card img {
            width: 100%;
            height: 150px;
            object-fit: cover;
        }
        .product-card .content {
            padding: 15px;
        }
        .product-card h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        .product-card .price {
            color: #3b82f6;
            font-weight: bold;
        }
        .product-card .source {
            font-size: 12px;
            color: #6b7280;
            margin-top: 10px;
        }
        code {
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
        .toggle-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .logs {
            background: #f9fafb;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>üîç Firebase Products Loading Test</h1>
    <p>Complete diagnostic check for product loading from Firebase database</p>

    <div class="test-section">
        <h2>üì° Firebase Connection Status</h2>
        <div id="firebase-status" class="status info">Checking Firebase connection...</div>
        <div id="firebase-details"></div>
    </div>

    <div class="test-section">
        <h2>üóÑÔ∏è Database Collections Check</h2>
        <div id="collections-status" class="status info">Checking database collections...</div>
        <div id="collections-details"></div>
    </div>

    <div class="test-section">
        <h2>üì¶ Products Loading Check</h2>
        <div id="products-status" class="status info">Checking product loading...</div>
        <div id="products-details"></div>
        <button class="toggle-btn" onclick="toggleProductsDisplay()">Toggle Products Display</button>
        <div id="products-display" style="display: none;"></div>
    </div>

    <div class="test-section">
        <h2>üñºÔ∏è Image Loading Check</h2>
        <div id="images-status" class="status info">Checking image loading...</div>
        <div id="images-details"></div>
    </div>

    <div class="test-section">
        <h2>üîß System Logs</h2>
        <button class="toggle-btn" onclick="toggleLogs()">Toggle Logs Display</button>
        <div id="logs-container" style="display: none;">
            <div id="system-logs" class="logs">Starting diagnostic check...\n</div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>

    <!-- Firebase Services -->
    <script src="firebase-config.js"></script>
    <script src="firebase-products-service.js"></script>
    <script src="firebase-auth-service.js"></script>

    <!-- Product Scripts -->
    <script src="products.js"></script>
    <script src="render.js"></script>

    <script>
        class ProductsLoadingTest {
            constructor() {
                this.logs = [];
                this.testResults = {
                    firebaseConnection: false,
                    databaseAccess: false,
                    productsLoaded: false,
                    imagesLoaded: false
                };
                this.productsData = {
                    featured: [],
                    categories: {},
                    userProducts: []
                };
                
                this.log('üöÄ Starting comprehensive products loading test...');
                this.startTest();
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[${timestamp}] ${message}`;
                this.logs.push(logMessage);
                
                const logsElement = document.getElementById('system-logs');
                if (logsElement) {
                    logsElement.textContent = this.logs.join('\n') + '\n';
                    logsElement.scrollTop = logsElement.scrollHeight;
                }
                console.log(logMessage);
            }

            updateStatus(elementId, message, type = 'info') {
                const element = document.getElementById(elementId);
                if (element) {
                    element.className = `status ${type}`;
                    element.textContent = message;
                }
            }

            updateDetails(elementId, content) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = content;
                }
            }

            async startTest() {
                await this.testFirebaseConnection();
                await this.testDatabaseCollections();
                await this.testProductsLoading();
                await this.testImageLoading();
                this.generateSummary();
            }

            async testFirebaseConnection() {
                this.log('üì° Testing Firebase connection...');
                
                try {
                    // Wait for Firebase to initialize
                    let attempts = 0;
                    while (attempts < 30) {
                        if (window.firebaseService && window.firebaseService.isReady()) {
                            this.testResults.firebaseConnection = true;
                            this.updateStatus('firebase-status', '‚úÖ Firebase connected successfully', 'success');
                            this.updateDetails('firebase-details', `
                                <p><strong>Firebase App:</strong> ${window.firebaseService.auth.app.name}</p>
                                <p><strong>Project ID:</strong> ${window.firebaseService.db.app.options.projectId}</p>
                                <p><strong>Auth State:</strong> ${window.firebaseService.auth.currentUser ? 'Authenticated' : 'Anonymous'}</p>
                                <p><strong>Connection Time:</strong> ${attempts * 100}ms</p>
                            `);
                            this.log('‚úÖ Firebase connection successful');
                            return;
                        }
                        await new Promise(resolve => setTimeout(resolve, 100));
                        attempts++;
                    }
                    
                    throw new Error('Firebase connection timeout');
                } catch (error) {
                    this.testResults.firebaseConnection = false;
                    this.updateStatus('firebase-status', '‚ùå Firebase connection failed', 'error');
                    this.updateDetails('firebase-details', `<p><strong>Error:</strong> ${error.message}</p>`);
                    this.log(`‚ùå Firebase connection failed: ${error.message}`);
                }
            }

            async testDatabaseCollections() {
                this.log('üóÑÔ∏è Testing database collections...');
                
                if (!this.testResults.firebaseConnection) {
                    this.updateStatus('collections-status', '‚ö†Ô∏è Skipped - Firebase not connected', 'warning');
                    return;
                }

                try {
                    const collections = ['featuredProducts', 'categoryProducts', 'userProducts'];
                    const collectionResults = {};

                    for (const collectionName of collections) {
                        try {
                            const snapshot = await window.firebaseService.db.collection(collectionName)
                                .limit(1)
                                .get();
                            
                            collectionResults[collectionName] = {
                                exists: true,
                                hasData: !snapshot.empty,
                                count: snapshot.size
                            };
                            this.log(`üìã Collection '${collectionName}': ${snapshot.empty ? 'Empty' : `${snapshot.size} documents found`}`);
                        } catch (error) {
                            collectionResults[collectionName] = {
                                exists: false,
                                error: error.message
                            };
                            this.log(`‚ùå Collection '${collectionName}' error: ${error.message}`);
                        }
                    }

                    this.testResults.databaseAccess = Object.values(collectionResults).some(result => result.exists);
                    
                    const hasData = Object.values(collectionResults).some(result => result.hasData);
                    
                    if (this.testResults.databaseAccess) {
                        this.updateStatus('collections-status', 
                            hasData ? '‚úÖ Database collections accessible with data' : '‚ö†Ô∏è Database accessible but no data found', 
                            hasData ? 'success' : 'warning'
                        );
                    } else {
                        this.updateStatus('collections-status', '‚ùå Database collections not accessible', 'error');
                    }

                    let detailsHTML = '<h4>Collection Status:</h4><ul>';
                    for (const [name, result] of Object.entries(collectionResults)) {
                        if (result.exists) {
                            detailsHTML += `<li><strong>${name}:</strong> ${result.hasData ? `‚úÖ ${result.count} documents` : '‚ö†Ô∏è Empty'}</li>`;
                        } else {
                            detailsHTML += `<li><strong>${name}:</strong> ‚ùå ${result.error}</li>`;
                        }
                    }
                    detailsHTML += '</ul>';
                    this.updateDetails('collections-details', detailsHTML);

                } catch (error) {
                    this.testResults.databaseAccess = false;
                    this.updateStatus('collections-status', '‚ùå Database access failed', 'error');
                    this.updateDetails('collections-details', `<p><strong>Error:</strong> ${error.message}</p>`);
                    this.log(`‚ùå Database access failed: ${error.message}`);
                }
            }

            async testProductsLoading() {
                this.log('üì¶ Testing products loading...');
                
                if (!this.testResults.databaseAccess) {
                    this.updateStatus('products-status', '‚ö†Ô∏è Skipped - Database not accessible', 'warning');
                    return;
                }

                try {
                    // Test Firebase Products Service
                    let attempts = 0;
                    while (attempts < 20) {
                        if (window.firebaseProductsService && window.firebaseProductsService.isInitialized) {
                            break;
                        }
                        await new Promise(resolve => setTimeout(resolve, 200));
                        attempts++;
                    }

                    if (window.firebaseProductsService && window.firebaseProductsService.isInitialized) {
                        this.log('‚úÖ Firebase Products Service initialized');
                        
                        // Get products from Firebase service
                        this.productsData.featured = window.firebaseProductsService.getFeaturedProducts();
                        this.productsData.categories = window.firebaseProductsService.getAllCategoryProducts();
                        this.productsData.userProducts = window.firebaseProductsService.getUserProducts();
                        
                        this.log(`üìä Featured products: ${this.productsData.featured.length}`);
                        this.log(`üìä Category products: ${Object.keys(this.productsData.categories).length} categories`);
                        this.log(`üìä User products: ${this.productsData.userProducts.length}`);
                    }

                    // Test static products from products.js
                    const staticProducts = window.products || [];
                    this.log(`üìä Static products: ${staticProducts.length}`);

                    // Test getAllProductsIncludingUserSubmitted function
                    let allProducts = [];
                    if (window.getAllProductsIncludingUserSubmitted) {
                        allProducts = window.getAllProductsIncludingUserSubmitted();
                        this.log(`üìä All products (including user submitted): ${allProducts.length}`);
                    }

                    const totalProducts = this.productsData.featured.length + 
                                        Object.values(this.productsData.categories).flat().length + 
                                        this.productsData.userProducts.length + 
                                        staticProducts.length;

                    this.testResults.productsLoaded = totalProducts > 0;

                    if (this.testResults.productsLoaded) {
                        this.updateStatus('products-status', `‚úÖ Products loaded successfully (${totalProducts} total)`, 'success');
                        
                        let detailsHTML = '<h4>Products Summary:</h4><ul>';
                        detailsHTML += `<li>Featured Products: ${this.productsData.featured.length}</li>`;
                        detailsHTML += `<li>Category Products: ${Object.values(this.productsData.categories).flat().length}</li>`;
                        detailsHTML += `<li>User Products: ${this.productsData.userProducts.length}</li>`;
                        detailsHTML += `<li>Static Products: ${staticProducts.length}</li>`;
                        detailsHTML += `<li><strong>Total: ${totalProducts}</strong></li>`;
                        detailsHTML += '</ul>';
                        
                        if (Object.keys(this.productsData.categories).length > 0) {
                            detailsHTML += '<h4>Categories:</h4><ul>';
                            for (const [category, products] of Object.entries(this.productsData.categories)) {
                                detailsHTML += `<li>${category}: ${products.length} products</li>`;
                            }
                            detailsHTML += '</ul>';
                        }
                        
                        this.updateDetails('products-details', detailsHTML);
                    } else {
                        this.updateStatus('products-status', '‚ùå No products found', 'error');
                        this.updateDetails('products-details', '<p>No products loaded from any source</p>');
                    }

                } catch (error) {
                    this.testResults.productsLoaded = false;
                    this.updateStatus('products-status', '‚ùå Products loading failed', 'error');
                    this.updateDetails('products-details', `<p><strong>Error:</strong> ${error.message}</p>`);
                    this.log(`‚ùå Products loading failed: ${error.message}`);
                }
            }

            async testImageLoading() {
                this.log('üñºÔ∏è Testing image loading...');
                
                if (!this.testResults.productsLoaded) {
                    this.updateStatus('images-status', '‚ö†Ô∏è Skipped - No products loaded', 'warning');
                    return;
                }

                try {
                    // Collect all products for image testing
                    const allProducts = [
                        ...this.productsData.featured,
                        ...Object.values(this.productsData.categories).flat(),
                        ...this.productsData.userProducts,
                        ...(window.products || [])
                    ];

                    if (allProducts.length === 0) {
                        this.updateStatus('images-status', '‚ö†Ô∏è No products available for image testing', 'warning');
                        return;
                    }

                    const imageTestResults = {
                        total: 0,
                        withImages: 0,
                        workingImages: 0,
                        brokenImages: 0,
                        fallbackImages: 0
                    };

                    const imagePromises = allProducts.slice(0, 10).map(async (product, index) => {
                        imageTestResults.total++;
                        
                        if (!product.image) {
                            this.log(`üì∏ Product "${product.name || product.title}" has no image`);
                            return { product, status: 'no-image' };
                        }

                        imageTestResults.withImages++;
                        
                        return new Promise((resolve) => {
                            const img = new Image();
                            img.onload = () => {
                                imageTestResults.workingImages++;
                                this.log(`‚úÖ Image loaded: ${product.name || product.title}`);
                                resolve({ product, status: 'loaded', url: product.image });
                            };
                            img.onerror = () => {
                                imageTestResults.brokenImages++;
                                this.log(`‚ùå Image failed: ${product.name || product.title} - ${product.image}`);
                                resolve({ product, status: 'broken', url: product.image });
                            };
                            img.src = product.image;
                            
                            // Timeout after 5 seconds
                            setTimeout(() => {
                                if (!img.complete) {
                                    imageTestResults.brokenImages++;
                                    this.log(`‚è∞ Image timeout: ${product.name || product.title}`);
                                    resolve({ product, status: 'timeout', url: product.image });
                                }
                            }, 5000);
                        });
                    });

                    await Promise.all(imagePromises);

                    this.testResults.imagesLoaded = imageTestResults.workingImages > 0;

                    if (this.testResults.imagesLoaded) {
                        this.updateStatus('images-status', `‚úÖ Images loading (${imageTestResults.workingImages}/${imageTestResults.withImages} successful)`, 'success');
                    } else {
                        this.updateStatus('images-status', '‚ùå No images loading successfully', 'error');
                    }

                    let detailsHTML = '<h4>Image Loading Results:</h4><ul>';
                    detailsHTML += `<li>Total Products Tested: ${imageTestResults.total}</li>`;
                    detailsHTML += `<li>Products with Images: ${imageTestResults.withImages}</li>`;
                    detailsHTML += `<li>Working Images: ${imageTestResults.workingImages}</li>`;
                    detailsHTML += `<li>Broken Images: ${imageTestResults.brokenImages}</li>`;
                    detailsHTML += '</ul>';
                    this.updateDetails('images-details', detailsHTML);

                } catch (error) {
                    this.testResults.imagesLoaded = false;
                    this.updateStatus('images-status', '‚ùå Image testing failed', 'error');
                    this.updateDetails('images-details', `<p><strong>Error:</strong> ${error.message}</p>`);
                    this.log(`‚ùå Image testing failed: ${error.message}`);
                }
            }

            generateSummary() {
                this.log('üìã Generating test summary...');
                
                const passedTests = Object.values(this.testResults).filter(result => result === true).length;
                const totalTests = Object.keys(this.testResults).length;
                
                this.log(`üéØ Test Summary: ${passedTests}/${totalTests} tests passed`);
                
                for (const [test, result] of Object.entries(this.testResults)) {
                    this.log(`${result ? '‚úÖ' : '‚ùå'} ${test}: ${result ? 'PASS' : 'FAIL'}`);
                }

                if (passedTests === totalTests) {
                    this.log('üéâ All tests passed! Products should be loading correctly.');
                } else {
                    this.log('‚ö†Ô∏è Some tests failed. Check the details above for issues.');
                }
            }

            displayProducts() {
                const container = document.getElementById('products-display');
                if (!container) return;

                const allProducts = [
                    ...this.productsData.featured,
                    ...Object.values(this.productsData.categories).flat(),
                    ...this.productsData.userProducts,
                    ...(window.products || [])
                ];

                if (allProducts.length === 0) {
                    container.innerHTML = '<p>No products to display</p>';
                    return;
                }

                let html = '<div class="product-grid">';
                allProducts.slice(0, 6).forEach(product => {
                    const imageUrl = product.image || 'https://images.unsplash.com/photo-1560472354-b33ff0c44a43?w=300&h=300&fit=crop&crop=center&auto=format&q=80';
                    html += `
                        <div class="product-card">
                            <img src="${imageUrl}" alt="${product.name || product.title}" onerror="this.src='https://images.unsplash.com/photo-1560472354-b33ff0c44a43?w=300&h=300&fit=crop&crop=center&auto=format&q=80'">
                            <div class="content">
                                <h3>${product.name || product.title || 'Untitled Product'}</h3>
                                <div class="price">${product.price || 'Price not available'}</div>
                                <div class="source">${product.type || 'static'}</div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                container.innerHTML = html;
            }
        }

        function toggleLogs() {
            const container = document.getElementById('logs-container');
            container.style.display = container.style.display === 'none' ? 'block' : 'none';
        }

        function toggleProductsDisplay() {
            const container = document.getElementById('products-display');
            container.style.display = container.style.display === 'none' ? 'block' : 'none';
            if (container.style.display === 'block' && window.testInstance) {
                window.testInstance.displayProducts();
            }
        }

        // Start the test when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                window.testInstance = new ProductsLoadingTest();
            }, 1000);
        });
    </script>
</body>
</html>